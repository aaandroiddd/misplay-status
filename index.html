<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>misplay.gg Status</title>
  <meta name="description" content="Real-time status and incident updates for misplay.gg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0b;
      --bg-card: #111113;
      --border: #27272a;
      --text: #fafafa;
      --text-muted: #a1a1aa;
      --accent: #38bdf8;
      --green: #22c55e;
      --yellow: #eab308;
      --red: #ef4444;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 1.5rem;
    }

    /* Header */
    header {
      border-bottom: 1px solid var(--border);
      padding: 1rem 0;
    }

    header .container {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 700;
      text-decoration: none;
      color: var(--text);
    }

    .logo span {
      color: var(--accent);
    }

    header nav a {
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.875rem;
      font-weight: 500;
      transition: color 0.2s;
    }

    header nav a:hover {
      color: var(--text);
    }

    /* Main */
    main {
      padding: 3rem 0;
    }

    /* Status Banner */
    .status-banner {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      text-align: center;
      margin-bottom: 3rem;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-dot.operational { background: var(--green); }
    .status-dot.degraded { background: var(--yellow); }
    .status-dot.outage { background: var(--red); }
    .status-dot.loading { background: var(--text-muted); }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-banner p {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    /* Services */
    .section-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .services {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 3rem;
    }

    .service {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
    }

    .service:last-child {
      border-bottom: none;
    }

    .service-name {
      font-weight: 500;
    }

    .service-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .service-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .service-status .dot.operational { background: var(--green); }
    .service-status .dot.degraded { background: var(--yellow); }
    .service-status .dot.outage { background: var(--red); }
    .service-status .dot.loading { background: var(--text-muted); }

    /* Uptime Section */
    .uptime-section {
      margin-bottom: 3rem;
    }

    .uptime-service {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.25rem 1.5rem;
      margin-bottom: 1rem;
    }

    .uptime-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.75rem;
      font-size: 0.875rem;
    }

    .uptime-label {
      font-weight: 500;
    }

    .uptime-percent {
      font-weight: 600;
    }

    .uptime-percent.good { color: var(--green); }
    .uptime-percent.degraded { color: var(--yellow); }
    .uptime-percent.bad { color: var(--red); }

    .uptime-bar-container {
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
    }

    .uptime-bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .uptime-bar.good { background: var(--green); }
    .uptime-bar.degraded { background: var(--yellow); }
    .uptime-bar.bad { background: var(--red); }

    /* Incidents */
    .incidents {
      margin-bottom: 3rem;
    }

    .incident {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .incident-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.75rem;
    }

    .incident-title {
      font-weight: 600;
    }

    .incident-date {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .incident-status {
      font-size: 0.75rem;
      font-weight: 500;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
    }

    .incident-status.resolved {
      background: rgba(34, 197, 94, 0.1);
      color: var(--green);
    }

    .incident-status.investigating {
      background: rgba(234, 179, 8, 0.1);
      color: var(--yellow);
    }

    .incident-body {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .no-incidents {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    /* Footer */
    footer {
      border-top: 1px solid var(--border);
      padding: 2rem 0;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    /* Setup Notice */
    .setup-notice {
      background: rgba(56, 189, 248, 0.1);
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    .setup-notice h3 {
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .setup-notice p {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .setup-notice code {
      background: var(--bg);
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .setup-notice ol {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-left: 1.25rem;
      margin-top: 0.75rem;
    }

    .setup-notice li {
      margin-bottom: 0.375rem;
    }

    .hidden {
      display: none;
    }

    /* Loading state */
    .loading-shimmer {
      background: linear-gradient(90deg, var(--border) 25%, var(--bg-card) 50%, var(--border) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <a href="https://misplay.gg" class="logo">misplay<span>.gg</span></a>
      <nav>
        <a href="https://misplay.gg">Back to misplay.gg</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- Setup Notice (shown when API key not configured) -->
    <div id="setup-notice" class="setup-notice hidden">
      <h3>Setup Required</h3>
      <p>To enable automatic monitoring, configure UptimeRobot:</p>
      <ol>
        <li>Create a free account at <a href="https://uptimerobot.com" target="_blank">uptimerobot.com</a></li>
        <li>Add monitors for your services (Website, API, etc.)</li>
        <li>Go to My Settings → API Settings → Create Read-Only API Key</li>
        <li>Edit this file and set <code>UPTIMEROBOT_API_KEY</code> to your key</li>
        <li>Update the <code>MONITORS</code> object with your monitor IDs</li>
      </ol>
    </div>

    <!-- Status Banner -->
    <div class="status-banner">
      <div class="status-indicator">
        <span id="overall-dot" class="status-dot loading"></span>
        <span id="overall-status">Checking status...</span>
      </div>
      <p>Last updated: <span id="last-updated">-</span></p>
    </div>

    <!-- Services Status -->
    <section>
      <h2 class="section-title">Services</h2>
      <div id="services-list" class="services">
        <!-- Services will be populated by JavaScript -->
      </div>
    </section>

    <!-- Uptime -->
    <section class="uptime-section">
      <h2 class="section-title">Uptime (Last 30 Days)</h2>
      <div id="uptime-list">
        <!-- Uptime bars will be populated by JavaScript -->
      </div>
    </section>

    <!-- Recent Incidents -->
    <section class="incidents">
      <h2 class="section-title">Recent Incidents</h2>
      <div id="incidents-list">
        <p class="no-incidents">No incidents reported.</p>
      </div>
    </section>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 misplay.gg &middot; <a href="https://misplay.gg">Main Site</a> &middot; Powered by <a href="https://uptimerobot.com" target="_blank">UptimeRobot</a></p>
    </div>
  </footer>

  <script>
    // ============================================
    // CONFIGURATION - Edit these values
    // ============================================

    // Your UptimeRobot Read-Only API Key
    const UPTIMEROBOT_API_KEY = 'ur3241166-1652b3049bf82ee22a27861f';

    // Map your monitor IDs to service names
    const MONITORS = {
      '802069201': 'Website',
      '802069213': 'Marketplace',
    };

    // Third-party services to monitor
    const THIRD_PARTY_SERVICES = {
      getstream: {
        name: 'Messaging (GetStream)',
        statusUrl: 'https://status.getstream.io/api/v2/status.json'
      }
    };

    // ============================================
    // STATUS PAGE LOGIC - Don't edit below
    // ============================================

    const STATUS_MAP = {
      0: { label: 'Paused', class: 'degraded' },
      1: { label: 'Not checked yet', class: 'loading' },
      2: { label: 'Operational', class: 'operational' },
      8: { label: 'Seems down', class: 'outage' },
      9: { label: 'Down', class: 'outage' }
    };

    const LOG_TYPE_MAP = {
      1: 'Down',
      2: 'Up',
      98: 'Started',
      99: 'Paused'
    };

    // Default services if no API key configured
    const DEFAULT_SERVICES = [
      { name: 'Website', status: 2, uptime: 100 },
      { name: 'Marketplace', status: 2, uptime: 100 }
    ];

    function updateLastUpdated() {
      const now = new Date();
      const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        timeZoneName: 'short'
      };
      document.getElementById('last-updated').textContent = now.toLocaleDateString('en-US', options);
    }

    function getOverallStatus(services) {
      const hasOutage = services.some(s => s.status === 8 || s.status === 9);
      const hasDegraded = services.some(s => s.status === 0 || s.status === 8);

      if (hasOutage) return { label: 'Service Disruption', class: 'outage' };
      if (hasDegraded) return { label: 'Degraded Performance', class: 'degraded' };
      return { label: 'All Systems Operational', class: 'operational' };
    }

    function getUptimeClass(uptime) {
      if (uptime >= 99.9) return 'good';
      if (uptime >= 99) return 'degraded';
      return 'bad';
    }

    function renderServices(services) {
      const container = document.getElementById('services-list');
      container.innerHTML = services.map(service => {
        const status = STATUS_MAP[service.status] || STATUS_MAP[1];
        return `
          <div class="service">
            <span class="service-name">${service.name}</span>
            <span class="service-status">
              <span class="dot ${status.class}"></span>
              ${status.label}
            </span>
          </div>
        `;
      }).join('');
    }

    function renderUptime(services) {
      const container = document.getElementById('uptime-list');
      container.innerHTML = services.map(service => {
        const uptimeClass = getUptimeClass(service.uptime);
        return `
          <div class="uptime-service">
            <div class="uptime-header">
              <span class="uptime-label">${service.name}</span>
              <span class="uptime-percent ${uptimeClass}">${service.uptime.toFixed(2)}%</span>
            </div>
            <div class="uptime-bar-container">
              <div class="uptime-bar ${uptimeClass}" style="width: ${service.uptime}%"></div>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderOverallStatus(services) {
      const overall = getOverallStatus(services);
      document.getElementById('overall-dot').className = `status-dot ${overall.class}`;
      document.getElementById('overall-status').textContent = overall.label;
    }

    function formatIncidentDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    }

    function formatDuration(seconds) {
      if (seconds < 60) return `${seconds}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
      const hours = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      return `${hours}h ${mins}m`;
    }

    function renderIncidents(incidents) {
      const container = document.getElementById('incidents-list');

      if (!incidents || incidents.length === 0) {
        container.innerHTML = '<p class="no-incidents">No incidents reported in the last 30 days.</p>';
        return;
      }

      container.innerHTML = incidents.map(incident => {
        const isResolved = incident.type === 2; // Type 2 = Up (resolved)
        const statusClass = isResolved ? 'resolved' : 'investigating';
        const statusText = isResolved ? 'Resolved' : 'Ongoing';

        return `
          <div class="incident">
            <div class="incident-header">
              <div>
                <h3 class="incident-title">${incident.monitorName} - ${incident.reason || 'Service Disruption'}</h3>
                <span class="incident-date">${formatIncidentDate(incident.datetime)}</span>
              </div>
              <span class="incident-status ${statusClass}">${statusText}</span>
            </div>
            <p class="incident-body">
              ${incident.duration ? `Duration: ${formatDuration(incident.duration)}` : 'Currently investigating...'}
            </p>
          </div>
        `;
      }).join('');
    }

    async function fetchThirdPartyStatus() {
      const results = [];

      for (const [key, service] of Object.entries(THIRD_PARTY_SERVICES)) {
        try {
          const response = await fetch(service.statusUrl);
          const data = await response.json();

          // Map Statuspage.io indicator to our status codes
          let status = 2; // Default: operational
          if (data.status) {
            switch (data.status.indicator) {
              case 'none': status = 2; break;      // Operational
              case 'minor': status = 0; break;     // Degraded
              case 'major': status = 8; break;     // Down
              case 'critical': status = 9; break;  // Down
              default: status = 2;
            }
          }

          results.push({
            name: service.name,
            status: status,
            uptime: 100, // Third-party doesn't provide uptime %
            isThirdParty: true,
            description: data.status?.description || 'Operational'
          });
        } catch (error) {
          console.error(`Failed to fetch ${service.name} status:`, error);
          results.push({
            name: service.name,
            status: 1, // Unknown
            uptime: 100,
            isThirdParty: true,
            description: 'Unable to fetch status'
          });
        }
      }

      return results;
    }

    async function fetchUptimeRobotStatus() {
      if (!UPTIMEROBOT_API_KEY || Object.keys(MONITORS).length === 0) {
        // Show setup notice and use defaults
        document.getElementById('setup-notice').classList.remove('hidden');
        return { services: DEFAULT_SERVICES, incidents: [] };
      }

      try {
        const response = await fetch('https://api.uptimerobot.com/v2/getMonitors', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            api_key: UPTIMEROBOT_API_KEY,
            format: 'json',
            custom_uptime_ratios: '30',
            logs: 1,
            log_types: '1-2',  // 1 = down, 2 = up
            logs_limit: 20,
            monitors: Object.keys(MONITORS).join('-')
          })
        });

        const data = await response.json();

        if (data.stat !== 'ok') {
          console.error('UptimeRobot API error:', data);
          return { services: DEFAULT_SERVICES, incidents: [] };
        }

        const services = data.monitors.map(monitor => ({
          name: MONITORS[monitor.id] || monitor.friendly_name,
          status: monitor.status,
          uptime: parseFloat(monitor.custom_uptime_ratio) || 100
        }));

        // Extract incidents (down events) from logs
        const incidents = [];
        data.monitors.forEach(monitor => {
          if (monitor.logs) {
            monitor.logs.forEach(log => {
              // Only show down events (type 1) - we'll pair them with their resolution
              if (log.type === 1) {
                incidents.push({
                  monitorName: MONITORS[monitor.id] || monitor.friendly_name,
                  type: log.type,
                  datetime: log.datetime,
                  duration: log.duration,
                  reason: log.reason?.detail || 'Service unavailable'
                });
              }
            });
          }
        });

        // Sort by date, most recent first
        incidents.sort((a, b) => b.datetime - a.datetime);

        return { services, incidents: incidents.slice(0, 10) };
      } catch (error) {
        console.error('Failed to fetch status:', error);
        return { services: DEFAULT_SERVICES, incidents: [] };
      }
    }

    async function init() {
      updateLastUpdated();

      // Fetch both UptimeRobot and third-party statuses in parallel
      const [uptimeData, thirdPartyServices] = await Promise.all([
        fetchUptimeRobotStatus(),
        fetchThirdPartyStatus()
      ]);

      // Combine all services
      const allServices = [...uptimeData.services, ...thirdPartyServices];

      renderServices(allServices);
      renderUptime(uptimeData.services); // Only show uptime for our services
      renderOverallStatus(allServices);
      renderIncidents(uptimeData.incidents);
      updateLastUpdated();
    }

    // Initialize on load
    init();

    // Refresh every 60 seconds
    setInterval(init, 60000);
  </script>
</body>
</html>
